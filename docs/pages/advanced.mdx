# Advanced: Details

## Account linking

Using multiple authentication methods poses an additional challenge: What should
happen when the same email address is used with a different method?

Signup via each authentication method is tracked in the
[`accounts`](/api_reference/server#accounts) table. Account linking determines
whether two accounts are linked to the same user document.

Convex Auth follows this logic:

1. Each provider is determined "trusted" or not, based on whether the email
   address ownership is verified.

   1. Email-based authentication methods ([magic links](/config/email) and
      [OTPs](/config/otps)) are trusted.
   2. [OAuth](/config/oauth) providers are trusted by default, since most
      popular OAuth providers today enforce email verification before the user
      can use them. You can make any OAuth provider untrusted by setting the
      `allowDangerousEmailAccountLinking` option to `false`:

      ```ts filename="convex/auth.ts"
      import Resend from "@auth/core/providers/resend";
      import GitHub from "@auth/core/providers/github";
      import { convexAuth } from "@xixixao/convex-auth/server";

      export const { auth, signIn, verifyCode, signOut, store } = convexAuth({
        providers: [
          Resend,
          GitHub({ allowDangerousEmailAccountLinking: false }),
        ],
      });
      ```

   3. Password-based accounts without required email verification are untrusted

2. If a trusted method is used, and there is a single existing user document
   with a given email address, signing in via the trusted method will link the
   new account to the same user document.
   - If there are multiple user documents with the same email address, then
     account linking is not performed.
3. If an untrusted method is used, the new account will not be linked to any
   existing one.

### Preventing duplicate user accounts

For now we recommend to not mix trusted and untrusted authentication methods. If
you don't want to have multiple user documents for the same email address, use
only trusted methods.

## Session validity

Convex Auth issues JWTs which allow your client to authenticate.

As far as the `ConvexReactClient` and the Convex backend with
`ctx.auth.getUserIdentity()` are concerned, the JWT is all that's needed for
valid authentication.

This means that when an existing session is invalidated (deleted), the user is
not automically signed out until the JWT expires.

If you want session validity to be reflected immediately, you need to actually
load the current session in your queries/mutations/actions, and you need to make
sure your client can handle the state where the JWT is valid but the session is
not.

Either way, for critical operations (changing account details) you should always
require either direct reauthentication or recent authentication. The current
session's `_creationTime` can be used to determine how recently the user has
signed in.

## Session document lifecycle

The session documents are created and deleted by Convex Auth.

For this reason if you're tying other documents to sessions, and you don't want
to lose information when the session expires, you should store both the session
ID and the user ID in your other document.
